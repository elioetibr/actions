name: CI

permissions:
  contents: write
  pull-requests: write
  id-token: write

on:
  push:
    branches:
      - '**'
  pull_request:
    branches: [main]
  workflow_dispatch:

# Concurrency control to implement build queue
# This ensures:
# 1. Only one workflow runs at a time for the same PR or branch
# 2. For main branch: new pushes are queued (not canceled)
# 3. For PRs: new pushes cancel previous runs to save resources
# 4. Different PRs can run in parallel
concurrency:
  # For main branch: queue builds but don't cancel in-progress ones
  # For PRs: cancel previous builds for the same PR
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref_name }}
  cancel-in-progress: ${{ github.ref_name != github.event.repository.default_branch }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: .nvmrc

      - name: Setup pnpm
        uses: actions/setup-node@v6

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linter
        run: pnpm run lint

      - name: Run type check
        run: pnpm run typecheck

      - name: Run tests
        run: pnpm test -- --coverage

      - name: Build
        run: pnpm run build

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/lcov.info
          fail_ci_if_error: false

      # Auto-commit dist/ changes on push to main
      - name: Commit dist/
        if: github.event_name == 'push' && github.ref_name == github.event.repository.default_branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add dist/
          git diff --staged --quiet || git commit -m "dist update" && git push

  release:
    name: Release
    runs-on: ubuntu-latest
    if: success() && github.event_name == 'push' && github.ref_name == github.event.repository.default_branch
    needs: [build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache GitVersion tool
        uses: actions/cache@v5
        with:
          path: |
            /opt/hostedtoolcache/GitVersion.Tool
            ~/.dotnet/tools
          key: ${{ runner.os }}-${{ runner.arch }}-gitversion-${{ vars.GITVERSION_SPEC || '6.x' }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-gitversion-

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v4.2.0
        with:
          versionSpec: ${{ vars.GITVERSION_SPEC || '6.x' }}

      - name: Calculate Semantic Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.2.0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install git-cliff
        uses: kenji-miyake/setup-git-cliff@v2

      - name: Generate changelog
        id: changelog
        env:
          VERSION: v${{ steps.gitversion.outputs.MajorMinorPatch }}
        run: |
          # Get the previous tag for changelog generation
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Generating changelog from $PREVIOUS_TAG to HEAD"
            git cliff "$PREVIOUS_TAG"..HEAD --tag "$VERSION" -o CHANGELOG.md
          else
            echo "No previous tag found, generating full changelog"
            git cliff --tag "$VERSION" -o CHANGELOG.md
          fi

          # Also generate release notes (just the latest version)
          if [ -n "$PREVIOUS_TAG" ]; then
            git cliff "$PREVIOUS_TAG"..HEAD --tag "$VERSION" --strip header -o RELEASE_NOTES.md
          else
            git cliff --tag "$VERSION" --strip all -o RELEASE_NOTES.md
          fi

          echo "Release notes:"
          cat RELEASE_NOTES.md

      - name: Tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FULL_VERSION: v${{ steps.gitversion.outputs.MajorMinorPatch }}
          MINOR_VERSION: v${{ steps.gitversion.outputs.Major }}.${{ steps.gitversion.outputs.Minor }}
          MAJOR_VERSION: v${{ steps.gitversion.outputs.Major }}
        run: |
          function tag() {
            VERSION=$1
            echo "Releasing Version: ${VERSION}"
            TAG_EXISTS=$(git ls-remote -q --tags | grep -q "refs/tags/${VERSION}$" && echo true || echo false)
            if [[ "${TAG_EXISTS}" == true ]]; then
              HAS_RELEASE=$(gh release list --json tagName -q '.[].tagName' | grep -E "^(${VERSION})$" && echo true || echo false)
              if [[ "${HAS_RELEASE}" == true ]]; then
                gh release delete --yes "${VERSION}"
              fi
              git push origin --delete "${VERSION}"
              git tag -d "${VERSION}"
            fi

            git tag -a "${VERSION}" -m "chore: Release Version ${VERSION}"
            git push -f --tags --follow-tags
          }

          # Create full version tag (v1.2.3)
          tag "$FULL_VERSION"

          # Create/update major.minor tag (v1.2)
          tag "$MINOR_VERSION"

          # Create/update major tag (v1)
          tag "$MAJOR_VERSION"

      - name: Update floating branches
        env:
          MAJOR: v${{ steps.gitversion.outputs.Major }}
          MINOR: v${{ steps.gitversion.outputs.Major }}.${{ steps.gitversion.outputs.Minor }}
        run: |
          # Update major branch (v1 -> latest v1.x.x)
          git push origin HEAD:refs/heads/"$MAJOR" --force

          # Update minor branch (v1.2 -> latest v1.2.x)
          git push origin HEAD:refs/heads/"$MINOR" --force

      - name: Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FULL_VERSION: v${{ steps.gitversion.outputs.MajorMinorPatch }}
        run: |
          # Clean up any draft releases
          gh release list | grep Draft | awk '{print $1}' | while read -r draft; do
            echo "Removing Draft Release: ${draft}"
            gh release delete --yes "${draft}"
          done

          # Create the release with conventional commits changelog
          gh release create "$FULL_VERSION" \
            --notes-file RELEASE_NOTES.md \
            --verify-tag \
            --latest
